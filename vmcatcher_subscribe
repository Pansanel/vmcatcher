#!/usr/bin/env python
import sys
if sys.version_info < (2, 4):
    print "Your python interpreter is too old. Please consider upgrading."
    sys.exit(1)

if sys.version_info < (2, 5):
    import site
    import os.path
    from distutils.sysconfig import get_python_lib
    found = False
    module_dir = get_python_lib()
    for name in os.listdir(module_dir):
        lowername = name.lower()
        if lowername[0:10] == 'sqlalchemy' and 'egg' in lowername:
            sqlalchemy_dir = os.path.join(module_dir, name)
            if os.path.isdir(sqlalchemy_dir):
                site.addsitedir(sqlalchemy_dir)
                found = True
                break
    if not found:
        print "Could not find SQLAlchemy installed."
        sys.exit(1)

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import IntegrityError, DatabaseError, ProgrammingError
import vmcatcher.databaseDefinition as model
import os
import re
import logging
import optparse
from smimeX509validation import TrustStore, LoadDirChainOfTrust,smimeX509validation, smimeX509ValidationError
from vmcatcher.__version__ import version
import vmcatcher
import urllib2
import urllib
import hashlib
import datetime
from hepixvmitrust.vmitrustlib import VMimageListDecoder as VMimageListDecoder
from hepixvmitrust.vmitrustlib import time_format_definition as time_format_definition
try:
    import simplejson as json
except:
    import json

# command line error codes.
#  10 failed to download image list.
#  11 failed to validate image list.
#  12 metadata and certificate dont match.
#  13 Endorser not authorised on subscription.
#  14 trust anchor missing
#  15 Database integrity error.
#  16 New version number is same as old version number.
#  17 New version number is less than old version number.


#  31 imagelist dc:identifier invalid.
#  32 image dc:identifier invalid.
#  33 imagelist dc:date:created invalid.
#  34 image has missing parameters in the message.
#  35 image has missing parameters in the message.
#  36 image is not registeresd with subscription.
#  37 Message was not valid JSON.
#  38 Message JSON was not valid to build image list.

regdelexp = re.compile('[-,.\/]')
regnumeric = re.compile('[0-9]+')

def split_line_by_delimiter(line,regex):
    splitline = []
    splititr = regex.finditer(line)
    lstart = 0
    for i in splititr:
        (mstart,mend) = i.span()
        if lstart != mstart:
            splitline.append(line[lstart:mstart])
        splitline.append(line[mstart:mend])
        lstart = mend
    linelen = len(line)
    if lstart != linelen:
        splitline.append(line[lstart:linelen])
    return splitline


def string_sort(x,y):
    xsplit = split_line_by_delimiter(x,regnumeric)
    ysplit = split_line_by_delimiter(y,regnumeric)
    ysplitlen = len(ysplit)
    xsplitlen = len(xsplit)
    minsplitlen = ysplitlen
    if xsplitlen < ysplitlen:
        minsplitlen = xsplitlen
    for i in range(minsplitlen):
        if xsplit[i] == ysplit[i]:
            continue
        if (xsplit[i].isdigit() and ysplit[i].isdigit()):
            rc = int(0)
            if int(xsplit[i]) > int(ysplit[i]):
                rc = -1
            if int(xsplit[i]) < int(ysplit[i]):
                rc = 1
            return rc
        if xsplit[i].isdigit():
            return -1
        if ysplit[i].isdigit():
            return 1
        if xsplit[i] > ysplit[i]:
            return -1
        if xsplit[i] < ysplit[i]:
            return 1
    if xsplitlen < ysplitlen:
        return 1
    if xsplitlen > ysplitlen:
        return -1
    return 0

def split_numeric_sort(x, y):
    xsplit = split_line_by_delimiter(x,regdelexp)
    ysplit = split_line_by_delimiter(y,regdelexp)
    ysplitlen = len(ysplit)
    xsplitlen = len(xsplit)
    minsplitlen = ysplitlen
    if xsplitlen < ysplitlen:
        minsplitlen = xsplitlen
    for i in range(minsplitlen):
        if xsplit[i] == ysplit[i]:
            continue
        if (xsplit[i].isdigit() and ysplit[i].isdigit()):
            rc = int(0)
            if int(xsplit[i]) > int(ysplit[i]):
                rc = -1
            if int(xsplit[i]) < int(ysplit[i]):
                rc = 1
            return rc
        if xsplit[i].isdigit():
            return -1
        if ysplit[i].isdigit():
            return 1
        rc = string_sort(xsplit[i],ysplit[i])
        if rc != 0:
            return rc
    if xsplitlen < ysplitlen:
        return 1
    if xsplitlen > ysplitlen:
        return -1
    return 0



class EventObj(object):
    def __init__(self,eventExecutionString):
        self.eventExecutionString = eventExecutionString
        self.env = os.environ
        self.log = logging.getLogger("Events")
    def launch(self,env):
        process = subprocess.Popen([self.eventExecutionString], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,env=env)
        processRc = None
        handleprocess = True
        counter = 0
        stdout = ''
        stderr = ''
        timeout = 10
        while handleprocess:
            counter += 1
            cout,cerr = process.communicate()
            stdout += cout
            stderr += cerr
            process.poll()
            processRc = process.returncode
            if processRc != None:
                break
            if counter == timeout:
                os.kill(process.pid, signal.SIGQUIT)
            if counter > timeout:
                os.kill(process.pid, signal.SIGKILL)
                processRc = -9
                break
            time.sleep(1)
        return (processRc,stdout,stderr)

    def eventProcess(self,EventStr,metadata):
        # Note keys 'sha512', 'uuid','size' are depricated.
        mappingdict = {'sha512' : 'VMCATCHER_EVENT_SL_CHECKSUM_SHA512',
            'uuid' : 'VMCATCHER_EVENT_DC_IDENTIFIER',
            'size' : 'VMCATCHER_EVENT_HV_SIZE',
            'sha512' : 'VMCATCHER_EVENT_SL_CHECKSUM_SHA512',
            # End of depricated options
            'filename' : 'VMCATCHER_EVENT_FILENAME',
            'dc:identifier' : 'VMCATCHER_EVENT_DC_IDENTIFIER',
            'hv:uri' : 'VMCATCHER_EVENT_HV_URI',
            'hv:size' : 'VMCATCHER_EVENT_HV_SIZE',
            'dc:description' : 'VMCATCHER_EVENT_DC_DESCRIPTION',
            'dc:title' : 'VMCATCHER_EVENT_DC_TITLE',
            'hv:hypervisor' : 'VMCATCHER_EVENT_HV_HYPERVISOR',
            'hv:version' : 'VMCATCHER_EVENT_HV_VERSION',
            'sl:arch' : 'VMCATCHER_EVENT_SL_ARCH',
            'sl:comments' : 'VMCATCHER_EVENT_SL_COMMENTS',
            'sl:os' : 'VMCATCHER_EVENT_SL_OS',
            'sl:osversion' : 'VMCATCHER_EVENT_SL_OSVERSION',
            'sl:checksum:sha512' : 'VMCATCHER_EVENT_SL_CHECKSUM_SHA512'}
        newEnv = self.env
        newEnv['VMCATCHER_EVENT_TYPE'] = EventStr
        for key in mappingdict.keys():
            if key in metadata.keys():
                newEnv[str(mappingdict[key])] = str(metadata[key])
        rc,stdout,stderr = self.launch(newEnv)
        if rc == 0:
            self.log.debug("event '%s' executed '%s'" % (newEnv['VMCATCHER_EVENT_TYPE'],self.eventExecutionString))
            self.log.debug("stdout=%s" % (stdout))
            self.log.debug("stderr=%s" % (stderr))
        else:
            self.log.error("Event '%s' executed '%s' with exit code '%s'." % (newEnv['VMCATCHER_EVENT_TYPE'],self.eventExecutionString,rc))
            self.log.info("stdout=%s" % (stdout))
            self.log.info("stderr=%s" % (stderr))
        return
    def eventImageNew(self,metadata):
        self.eventProcess("ImageNew",metadata)








class db_actions(object):
    def __init__(self,session):
        self.session = session
        self.log = logging.getLogger("db_actions")
    def endorser_get(self,metadata):
        return self.session.query(model.Endorser).\
                filter(model.Endorser.id==model.EndorserPrincible.id).\
                filter(model.EndorserPrincible.hv_dn==metadata[u'hv:dn']).\
                filter(model.EndorserPrincible.hv_ca==metadata[u'hv:ca'])
    def endorser_create(self,metadata):
        hv_dn_str = metadata[u'hv:dn']
        gotquery = self.session.query(model.Endorser).\
            filter(model.Endorser.id==model.EndorserPrincible.id).\
            filter(model.EndorserPrincible.hv_dn==metadata[u'hv:dn'])
        if gotquery.count() != 0:
            return gotquery
        newlist = model.Endorser(metadata)
        self.session.add(newlist)
        self.session.commit()
        new_endorser = model.EndorserPrincible(newlist.id,metadata)

        self.session.add(new_endorser)
        self.session.commit()
        return self.endorser_get(metadata)
    def subscription_get(self,metadata):
        subscriptionlist = self.session.query(model.Subscription).\
                filter(model.Subscription.uri==metadata[u'hv:uri'])
        return subscriptionlist

    def subscription_create(self,metadata,authorised):
        subscription_query = self.subscription_get(metadata)
        if subscription_query.count() > 0:
            return subscription_query
        endorser_list = self.endorser_get(metadata)
        if endorser_list.count() == 0:
            return subscription_query
        endorser = endorser_list.one()
        endorserId = int(endorser.id)
        new_subscription = model.Subscription(metadata)
        # We will make the new subscription enabled by default
        new_subscription.authorised = True
        self.session.add(new_subscription)
        self.session.commit()
        new_auth = model.SubscriptionAuth(new_subscription.id,endorser.id,authorised)
        self.session.add(new_auth)
        try:
            self.session.commit()
        except IntegrityError,E:
             self.log.error("Database integrity error '%s' while subscribing to  '%s'." % (E.args,metadata))
             self.log.debug(E.params)
             self.session.rollback()
        return self.subscription_get(metadata)

    def ImageDefinition_get(self,subscriptionKey,metadata):
        subscriptionlist = self.session.query(model.ImageDefinition).\
                filter(model.ImageDefinition.subscription==subscriptionKey).\
                filter(model.ImageDefinition.identifier == metadata[u'dc:identifier'])
        return subscriptionlist

    def ImageDefinition_create(self,subscriptionKey,metadata):
        ImageDefinitionQuery = self.ImageDefinition_get(subscriptionKey,metadata)
        if ImageDefinitionQuery.count() > 0:
            return ImageDefinitionQuery
        newlist = model.ImageDefinition(subscriptionKey,metadata)
        self.session.add(newlist)
        self.session.commit()
        ImageDefinitionQuery = self.ImageDefinition_get(subscriptionKey,metadata)
        return ImageDefinitionQuery
    def ImageDefinition_delete(self,subscriptionKey,metadata):
        self.log.error("not yet implemented")
    def ImageDefinition_list(self,subscriptionKey):
        imagedefList = self.session.query(model.ImageDefinition).\
                filter(model.ImageDefinition.subscription==subscriptionKey)
        return imagedefList


class queryby_base(object):
    """"Base class for querying subscriptions"""
    def __init__(self,session):
        self.session = session
    def subscription_by_id(self,private_id):
        subscriptionlist = self.session.query(model.Subscription).\
                filter(model.Subscription.id==private_id)
        return subscriptionlist
    def subscription_by_uri(self,uri):
        subscriptionlist = self.session.query(model.Subscription).\
                filter(model.Subscription.uri==uri)
        return subscriptionlist
    def subscription_by_uuid(self,uuid):
        subscriptionlist = self.session.query(model.Subscription).\
                filter(model.Subscription.identifier==uuid)
        return subscriptionlist
    def imagelist_by_id(self,private_id):
        subscriptionlist = self.session.query(model.ImageListInstance).\
                filter(model.ImageListInstance.id==private_id)
        return subscriptionlist

        # Now the virtual class
    def subscription_get(self,by_id):
        return self.subscription_by_id(private_id)


class queryby_uri(queryby_base):
    def subscription_get(self,url):
        return self.subscription_by_uri(url)

class queryby_uuid(queryby_base):
    def subscription_get(self,uuid):
        return self.subscription_by_uuid(uuid)


class output_driver_base(object):
    def __init__(self,file_pointer,session,anchor):
        self.session = session
        self.log = logging.getLogger("db_actions")
        self.file_pointer = file_pointer
        self.anchor = anchor
    def display_subscription_imagelist(self,subscription,imagelist):
        status = None

        self.display_subscription(subscription)
        self.display_imagelist(imagelist)

        return True
    def display_subscription(self,subscription):
        pass
    def display_imagelist(self,imagelist):
        pass
    def subscriptions_lister(self):
        pass

class output_driver_smime(output_driver_base):
    def display_subscription(self,subscription):
        pass
    def display_imagelist(self,imagelist):
        self.file_pointer.write (imagelist.data)

class output_driver_message(output_driver_base):
    def __init__(self,file_pointer,session,anchor):
        output_driver_base.__init__(self,file_pointer,session,anchor)
        self.log = logging.getLogger("output_driver_message")
    def display_subscription(self,subscription):
        pass
    def display_imagelist(self,imagelist):
        smimeProcessor =  smimeX509validation(self.anchor)
        try:
            smimeProcessor.Process(str(imagelist.data))
        except smimeX509ValidationError,E:
            self.log.error("Failed to validate text for '%s' produced error '%s'" % (imagelist,E))
            return False
        if not smimeProcessor.verified:
            self.log.error("Failed to validate text for '%s' produced error '%s'" % (subscriptionKey,E))
            return False
        self.file_pointer.write (smimeProcessor.InputDaraStringIO.getvalue())
        return True

class output_driver_lines(output_driver_base):
    def display_subscription(self,subscription):
        self.file_pointer.write ('subscription.dc:identifier=%s\n' % (subscription.identifier))
        self.file_pointer.write ('subscription.dc:description=%s\n' % (subscription.description))
        self.file_pointer.write ('subscription.sl:authorised=%s\n' % (subscription.authorised))
        self.file_pointer.write ('subscription.hv:uri=%s\n' % (subscription.uri))
        if subscription.updated:
            self.file_pointer.write ('subscription.dc:date:updated=%s\n' % (subscription.updated.strftime(time_format_definition)))
        else:
            self.file_pointer.write ('subscription.dc:date:updated=%s\n'% (False))
        return True

    def display_imagelist(self,imagelist):
        self.file_pointer.write ('imagelist.dc:date:imported=%s\n' % (imagelist.imported.strftime(time_format_definition)))
        self.file_pointer.write ('imagelist.dc:date:created=%s\n' % (imagelist.created.strftime(time_format_definition)))
        self.file_pointer.write ('imagelist.dc:date:expires=%s\n' % (imagelist.expires.strftime(time_format_definition)))
        if imagelist.expired == None:
            self.file_pointer.write ('imagelist.expired=0\n')
        else:
            self.file_pointer.write ('imagelist.expired=%s\n' % (imagelist.expired.strftime(time_format_definition)))
    def subscriptions_lister(self):
        subauthq = self.session.query(model.Subscription).all()
        for item in subauthq:
            self.file_pointer.write ("%s\t%s\t%s\n" % (item.identifier,item.authorised,item.uri))

class fileView(object):
    def __init__(self,anchor,fileRaw,MatchMetadata):
        self.log = logging.getLogger("fileView")
        self.anchor = anchor
        self.data = fileRaw
        self.errorNo = 0
        self.vmilist = None
        self.MatchMetadata = MatchMetadata
        self.Json = None
        self.checkmessage()
        
        
    def checkmessage(self):
        # hello
        #print str(self.MatchMetadata)
        now = datetime.datetime.utcnow()
        smimeProcessor =  smimeX509validation(self.anchor)
        try:
            smimeProcessor.Process(str(self.data))
        except smimeX509ValidationError,E:
            self.log.error("Failed to process validate text for produced error" )
            # Error code - failed to validate image list.
            self.errorNo =  11
            return
        if not smimeProcessor.verified:
            self.log.error("Failed to validate text for '%s' produced error '%s'" % (subscriptionKey,E))
            self.errorNo =  11
            return
        data = smimeProcessor.InputDaraStringIO.getvalue()
        self.subject = smimeProcessor.InputCertMetaDataList[0]['subject']
        self.issuer = smimeProcessor.InputCertMetaDataList[0]['issuer']
        jsonData = json.loads(data)
        if jsonData == None:
            self.log.error("Downlaoded metadata from '%s' was not valid JSON." % (subscriptionKey))
            self.errorNo =  37
            return
        vmilist = VMimageListDecoder(jsonData)
        if vmilist == None:
            self.log.error("Downlaoded metadata from '%s' was not valid image list Object." % (subscriptionKey))
            self.errorNo =  38
            return
        self.vmilist = vmilist
        if vmilist.endorser.metadata[u'hv:dn'] != self.subject:
            self.log.error("Endorser DN does not match signature for '%s'" (self.MatchMetadata[u'dc:identifier']))
            self.log.info("Expected DN '%s'" % (vmilist.endorser.metadata[u'hv:dn']))
            self.log.info("Downloaded DN '%s'" % (self.subject))
            # Error code - metadata and certificate dont match.
            self.errorNo =  12
            return
        if vmilist.endorser.metadata[u'hv:ca'] != self.issuer:
            self.log.error("list hv:ca does not match signature for '%s'" % (self.MatchMetadata[u'dc:identifier']))
            self.log.info("Expected CA '%s'" % (vmilist.endorser.metadata[u'hv:ca']))
            self.log.info("Downloaded CA '%s'" % (self.issuer))
            # Error code - metadata and certificate dont match.
            self.errorNo =  12
            return
            
        if vmilist.metadata[u'hv:uri'] != self.MatchMetadata[u'hv:uri']:
            self.log.error("list hv:uri does not match subscription uri for '%s'" % (self.MatchMetadata[u'dc:identifier']))
            self.log.info("Expected URI '%s'" % (subscription.uri))
            self.log.info("Downloaded URI '%s'" % (vmilist.metadata[u'hv:uri']))
            # Error code - metadata and certificate dont match.
            self.errorNo =  12
            return
        
        if vmilist.metadata[u'dc:identifier'] != self.MatchMetadata[u'dc:identifier']:
            self.log.info("Expected identifier '%s'" % (self.MatchMetadata[u'dc:identifier']))
            self.log.info("Downloaded identifier '%s'" % (vmilist.metadata[u'dc:identifier']))
            # Error code - imagelist dc:identifier invalid.
            self.errorNo =  31
            return
        now = datetime.datetime.utcnow()
        if now < vmilist.metadata[u'dc:date:created']:
            self.log.error("Image list '%s' has an invalid creation date as in the future." % (self.MatchMetadata[u'dc:identifier']))
            self.errorNo =  33
            return
        if now > vmilist.metadata[u'dc:date:expires']:
            self.log.warning("Downloaded image list '%s' has expired." % (self.MatchMetadata[u'dc:identifier']))
            self.errorNo =  34
            return
        self.vmilist = vmilist
        self.errorNo = 0
        self.Json = jsonData
        return 
class db_controler(object):
    def __init__(self,dboptions,dblog = False):
        self.log = logging.getLogger("db_controler")
        self.engine = create_engine(dboptions, echo=dblog)
        model.init(self.engine)
        self.SessionFactory = sessionmaker(bind=self.engine)
        self.anchor = None
        self.factory_selector = None
        self.factory_view = None
        # Set all callbacks to empty
        self.callbackEventImageNew = None

    def setup_trust_anchor(self,directory):
        self.anchor = LoadDirChainOfTrust(directory)
    def setup_selector_factory(self,factory):
        self.factory_selector = factory
    def setup_view_factory(self,factory):
        self.factory_view = factory

    # Utility functions
    def check_factories(self):
        if self.factory_view == None:
            self.log.warning("factory_view not available.")
            return False
        if self.factory_selector == None:
            self.log.warning("selector not available.")
            return False
        return True
    def unsigned_message_by_identifier_tofilepath(self,instructions):


        Session = self.SessionFactory()
        db = db_actions(Session)
        for instruction in instructions:
            print instruction

        for selection_uuid in subscriptions_selected:
            db.sdsdsd(selection_uuid)
        Session.commit()
    def sessions_list(self):
        Session = self.SessionFactory()
        selector = self.factory_selector(Session)
        view = self.factory_view(sys.stdout,Session,self.anchor)
        view.subscriptions_lister()
        return True
    
    def subscriptions_delete(self,subscriptions_selected):
        foundOne = False
        Session = self.SessionFactory()
        db = db_actions(Session)
        selector = self.factory_selector(Session)
        for selection_item in subscriptions_selected:
            query_subscription = selector.subscription_get(selection_item)
            for a_sub in query_subscription:
                # should not need thsi code but do maybe a bug in slqalchamy or more likely my db definition"
                query_image_def_linked = db.ImageDefinition_list(a_sub.id)
                for image_def_linked in query_image_def_linked:
                    Session.delete(image_def_linked)
                Session.delete(a_sub)
                foundOne = True
        Session.commit()
        return foundOne
    def subscriptions_subscribe(self,urls_selected,autoEndorse):
        rc = True
        Session = self.SessionFactory()
        db = db_actions(Session)
        for uri in urls_selected:
            if not self.subscribe_file(Session,self.anchor,uri,autoEndorse):
                rc = False
        return rc


    def subscriptions_info(self,subscriptions_selected,outputfiles):
        if not self.check_factories():
            return False
        pairs, extra_selectors ,extra_paths = pairsNnot(subscriptions_selected,outputfiles)

        for item in extra_selectors:
            pairs.append([item,None])

        errorhappened = False
        Session = self.SessionFactory()
        selector = self.factory_selector(Session)
        for pair in pairs:
            selector_filter = pair[0]
            output_file_name = pair[1]
            output_fileptr = sys.stdout
            if output_file_name != None:
                output_fileptr = open(output_file_name,'w+')
                output_fileptr.flush()
            query_subscription = selector.subscription_get(selector_filter)
            if query_subscription.count() == 0:
                self.log.warning("Selections '%s' does not match any known subscriptions." % (selector_filter))
                continue
            view = self.factory_view(output_fileptr,Session,self.anchor)

            for item in query_subscription:
                view.display_subscription(item)
                query_imagelist = selector.imagelist_by_id(item.imagelist_latest)
                for imagelist in query_imagelist:
                    view.display_imagelist(imagelist)

            if output_file_name != None:
                output_fileptr.close()
    def setEventObj(self,obj):
        self.eventObj = obj

    def subscribe_file(self,Session,anchor,filename,autoEndorse):
        req = urllib2.Request(url=filename)
        f = urllib2.urlopen(req)
        smimeProcessor = smimeX509validation(anchor)
        try:
            smimeProcessor.Process(f.read())
        except smimeX509ValidationError,E:
            self.log.error("Validate text '%s' produced error '%s'" % (filename,E))
            return False
        if not smimeProcessor.verified:
            self.log.error("Failed to  verify text '%s'" % (filename))
            return False
        jsontext = json.loads(smimeProcessor.InputDaraStringIO.getvalue())
        if jsontext == None:
            self.log.error("Message downlaoded from '%s' was not valid JSON." % (filename))
            return False
        vmilist = VMimageListDecoder(jsontext)
        if vmilist == None:
            self.log.error("Failed to decode the json as an image list Object for '%s'." % (filename))
            return False
        metadata = {}
        metadata.update(vmilist.metadata)
        metadata.update(vmilist.endorser.metadata)
        if u'dc:identifier' not in metadata.keys():
            self.log.error('list dc:identifier does not found')
            return False
        if metadata[u'hv:dn'] != smimeProcessor.InputCertMetaDataList[0]['subject']:
            self.log.error('Endorser DN does not match signature')
            return False
        if metadata[u'hv:ca'] != smimeProcessor.InputCertMetaDataList[0]['issuer']:
            self.log.error('list hv:ca does not match signature')
            return False
        if metadata[u'hv:uri'] != filename:
            self.log.warning('list hv:uri does not match subscription uri')
        db = db_actions(Session)
        endorser_list = db.endorser_get(metadata)
        if endorser_list.count() == 0:
            if not autoEndorse:
                self.log.error("Endorser '%s':'%s' was not found in database." % (metadata[u'hv:dn'],metadata[u'hv:ca']))
                self.log.info("Use '--auto-endorse' to add endorser '%s':'%s' to subscription database." % (metadata[u'hv:dn'],metadata[u'hv:ca']))
                return False
            else:
                # We can create an endorser.
                endorser_list = db.endorser_create(metadata)
                self.log.warning("Endorser '%s':'%s' added to database." % (metadata[u'hv:dn'],metadata[u'hv:ca']))
                
                if endorser_list.count() == 0:
                    self.log.error('Failed to create an authorised endorser in Database.')
                    return False
        subscription_query = db.subscription_create(metadata,True)
        if subscription_query.count() != 1:
            self.log.error('Creation of Subscription referance failed.')
            return False
        subscription = subscription_query.one()
        subscriptionKey = int(subscription.id)
        failedToCreateImages = []
        for imageReferance in vmilist.images:
            # Now we creat image definitions
            metadata = {}
            metadata.update(imageReferance.metadata)
            imagekey = imageReferance.metadata[u'dc:identifier']
            metadata['cache'] = 0
            if self.subscript_image_bind(Session,subscriptionKey,imagekey)
                self.log.error('Creation of ImageDefinition referance failed.')
                failedToCreateImages.append(imageReferance)
                continue
        if len(failedToCreateImages) > 0:
            return False
        return True
    
    def subscript_image_bind(self,Session,subscriptionKey,image):
        db = db_actions(Session)
        
        metadata[u'dc:identifier'] = image
        ImageDefinition_query = db.ImageDefinition_create(subscriptionKey,metadata)
        if ImageDefinition_query.count() != 1:
            self.log.error('Creation of ImageDefinition referance failed.')
            return False
        return True
    
    
    def subscript_update_image(self,Session,subscription,imagelistref,imageObj):
        subscriptionKey = subscription.id
        ProcessingSubscriptionUuid = subscription.identifier
        if not u'dc:identifier' in imageObj.metadata.keys():
            self.log.error('Image had no ID so ignored')
            # Error code - imagelist dc:identifier invalid.
            return 31
        db = db_actions(Session)
        imageDefQuery = db.ImageDefinition_get(subscriptionKey,imageObj.metadata)
        if imageDefQuery.count() != 1:
            if self.callbackEventImageNew != None:
                self.callbackEventImageNew(imageObj.metadata)
            # Triggor an event for new image.
            self.log.error("ImageId '%s' not accepted for subscription '%s'" %
                (imageObj.metadata[u'dc:identifier'],ProcessingSubscriptionUuid))
            # Error code - image dc:identifier invalid.
            return 32
        ThisImageDef = imageDefQuery.one()

        ThisImageDefId = int(ThisImageDef.id)
        #print ("ThisImageDefId=%s" % (ThisImageDefId))
        try:
            imageinstance = model.ImageInstance(imagelistref,ThisImageDefId,imageObj.metadata)
        except KeyError, E:
            self.log.error("missing parameters '%s'" % E.message)
            Session.rollback()
            return 34
        Session.add(imageinstance)
        try:
            Session.commit()
        except IntegrityError,E:
            self.log.error("Database integrity error '%s' processing '%s'." % (E.args,ProcessingSubscriptionUuid))
            self.log.debug(E.params)
            Session.rollback()
            return 0
        # So now we have done the updating of the database and just need to update 
        # the latest image instance record in the database.
        
        latestimageInstanceQuery = Session.query(model.ImageInstance).\
            filter(model.ImageInstance.fkimagelistinstance == imagelistref).\
            filter(model.ImageInstance.fkIdentifier == ThisImageDefId)
        if latestimageInstanceQuery.count() != 1:
            return 0
        imageInstancelatest = latestimageInstanceQuery.one()
        imageDefQuery = db.ImageDefinition_get(subscriptionKey,imageObj.metadata)
        if imageDefQuery.count() != 1:
            self.log.error("ImageId '%s' not accepted for subscription '%s'" %
                (imageObj.metadata[u'dc:identifier'],ProcessingSubscriptionUuid))
            return 36
        ThisImageDef = imageDefQuery.one()
        ThisImageDef.latest = imageInstancelatest.id
        Session.add(ThisImageDef)
        Session.commit()
        return 0
    

    def subscription_update(self,Session,subscription):
        subscriptionKey = int(subscription.id)
        ProcessingSubscriptionUuid = str(subscription.identifier)
        self.log.info("Updating:%s" % (ProcessingSubscriptionUuid))
        req = urllib2.Request(url=subscription.uri)
        try:
            f = urllib2.urlopen(req)
        except urllib2.URLError,E:
            # Python 2.6 Exception
            self.log.error("Download of url '%s' failed." % (subscription.uri))
            # Error code - failed to download image list.
            return 10
        except OSError:
            # Python 2.4 Exception
    	    self.log.error("Download of url '%s' failed." % (subscription.uri))
            # Error code - failed to download image list.
            return 10
        update_unprocessed = str(f.read())
        # Now we have the update lets first check its hash
        messagehash = hashlib.sha512(update_unprocessed).hexdigest()
        now = datetime.datetime.utcnow()
        metadataFV = {
            u'hv:uri' : str(subscription.uri),
            u'dc:identifier' : str(subscription.identifier),
        }
        #self.log.error("errr:%s" % (ProcessingSubscriptionUuid))
        checker = fileView(self.anchor,update_unprocessed,metadataFV)
        if checker.errorNo != 0:
            return checker.errorNo
        if checker.Json == None:
            return 14
        metadata = checker.vmilist.metadata
        metadata[u'data'] = update_unprocessed
        metadata[u'data-hash'] = messagehash
        if checker.errorNo != 0:
            self.log.info('Message Expired:%s' % (ProcessingSubscriptionUuid))
            metadata[u'expired'] = now
            Session.commit()
        # Now we know the data better check the SubscriptionAuth
        subq = Session.query(model.Subscription, model.SubscriptionAuth).\
            filter(model.Endorser.id == model.EndorserPrincible.id).\
            filter(model.EndorserPrincible.hv_dn == checker.subject).\
            filter(model.EndorserPrincible.hv_ca == checker.issuer).\
            filter(model.SubscriptionAuth.endorser == model.Endorser.id).\
            filter(model.SubscriptionAuth.subscription == model.Subscription.id).\
            filter(model.Subscription.id == subscription.id)

        count = subq.count()
        if count == 0:
            self.log.error('Endorser not authorised on subscription %s' % (ProcessingSubscriptionUuid))
            # Error code - Endorser not authorised on subscription.
            return 13
        if count != 1:
            self.log.error('Database Error processing subq:%s' % (ProcessingSubscriptionUuid))
            assert (False)
        subscription, auth = subq.one()
        
        
        # Sets 
        VersionCompare = 0
        qeryJunction = Session.query(model.ImageListInstance).\
            filter(model.Subscription.imagelist_latest == model.ImageListInstance.id).\
            filter(model.Subscription.id == subscription.id)
        
        
        
        if qeryJunction.count() == 0:
            #"we have no older version"
            self.log.info("First version of:%s" % (ProcessingSubscriptionUuid))
        else:
            if qeryJunction.count() != 1:
                self.log.error('Database Error processing  qeryJunction:%s' % (ProcessingSubscriptionUuid))
                assert (False)
            imageList = qeryJunction.one()
            if imageList.data_hash == messagehash:
                self.log.debug('Same version:%s' % (ProcessingSubscriptionUuid))
                if now > imageList.expires:
                    self.log.info("Image list '%s' has expired on: '%s'" % (ProcessingSubscriptionUuid,imageList.expires))
                    if imageList.expired == None:
                        imageList.expired = now
                        Session.commit()
                # We now know imageList is not too old.
                if ((imageList.expired != None) and (checker.errorNo == 0)):
                    # we have expired previously but now it looks good.
                    self.log.info('imageList Validated:%s' % (ProcessingSubscriptionUuid))
                    imageList.expired = None
                    Session.commit()
                if ((imageList.expired == None) and (checker.errorNo != 0)):
                    # should expire.
                    self.log.info('imageList Expired:%s' % (ProcessingSubscriptionUuid))
                    imageList.expired = now
                    Session.commit()
                return 0    
            messageVersion = checker.Json[u'hv:imagelist'][u'hv:version']
            self.log.debug('Downloaded version:%s' % (messageVersion))
            VersionCompare = split_numeric_sort(imageList.version,messageVersion)
            if VersionCompare == 0:
                self.log.error('Downloaded version "%s" has the same version number than the old version "%s".' % (messageVersion, imageList.version))                
                return 16 #  16 New version number is same as old version number.
            if VersionCompare < 0:
                self.log.error('Downloaded version "%s" has lower version number than the old version "%s".' % (messageVersion, imageList.version))
                return 17 #  17 New version number is less than old version number.
        
        
        imagelist = model.ImageListInstance(auth.id,metadata)
        Session.add(imagelist)
        try:
            Session.commit()
        except IntegrityError,E:
            self.log.error("Database integrity error '%s' processing '%s'." % (E.args,ProcessingSubscriptionUuid))
            self.log.debug(E.params)
            Session.rollback()
            # Error code - Database integrity error.
            return 15
        imagelistref = int(imagelist.id)
        # Now make a global return number
        globalRc = 0
        for imageObj in checker.vmilist.images:
            # Now update each Image
            thisRc = self.subscript_update_image(Session,subscription,imagelistref,imageObj)
            if thisRc != 0:
                globalRc = thisRc

        if subscription.imagelist_latest != None:
            oldimagelist_q = Session.query(model.ImageListInstance).\
                filter(model.ImageListInstance.id == subscription.imagelist_latest)
            for imagelist in oldimagelist_q:
                imagelist.authorised = False
                Session.add(imagelist)
        subscription.updated = datetime.datetime.utcnow()

        subscription.imagelist_latest = imagelistref
        Session.add(subscription)
        Session.commit()
        return globalRc
        
    def subscriptions_update(self):
        if self.anchor == None:
            self.log.warning("No enabled certificates, check your x509 dir.")
            return 12
        Session = self.SessionFactory()
        db = db_actions(Session)
        rc = 0
        subscriptionlist = Session.query(model.Subscription).all()
        for subscription in subscriptionlist:
            thisRc = self.subscription_update(Session,subscription)
            if thisRc != 0:
                rc = thisRc
        return rc
         

# User interface

def pairsNnot(list_a,list_b):
    len_generate_list = len(list_a)
    len_image_list = len(list_b)
    ocupies_generate_list = set(range(len_generate_list))
    ocupies_image_list = set(range(len_image_list))
    ocupies_pairs = ocupies_image_list.intersection(ocupies_generate_list)
    diff_a = ocupies_generate_list.difference(ocupies_image_list)
    diff_b = ocupies_image_list.difference(ocupies_generate_list)
    arepairs = []
    for i in ocupies_pairs:
        arepairs.append([list_a[i],list_b[i]])
    notpairs_a = []
    for i in diff_a:
        notpairs_a.append(list_a[i])
    notpairs_b = []
    for i in diff_b:
        notpairs_b.append(list_b[i])

    return arepairs,notpairs_a,notpairs_b



def main():
    log = logging.getLogger("main")
    """Runs program and handles command line options"""
    p = optparse.OptionParser(version = "%prog " + version)
    p.add_option('-l', '--list', action ='store_true',help='list subscriptions')
    p.add_option('-d', '--database', action ='store', help='Database Initiation string')
    p.add_option('-s', '--subscribe', action ='append',help='Subscribe to imagelist available at URI', metavar='INPUTURL')
    p.add_option('-e', '--auto-endorse', action ='store_true',help='Add endorser in your subscribe to imagelist action.')
    p.add_option('-c', '--cert-dir', action ='store',help='Certificate directory.', metavar='INPUTDIR')
    p.add_option('-U', '--update', action ='store_true',help='update image metadata')
    p.add_option('-u', '--uuid', action ='append',help='Select subscription', metavar='UUID')
    p.add_option('-r', '--uri', action ='append',help='Select subscription', metavar='URL')
    p.add_option('-f', '--format', action ='store',help='Sets the output format')
    p.add_option('-D', '--delete', action ='store_true',help='Delete subscription')
    p.add_option('-i', '--info', action ='store_true',help='Information on subscription')
    p.add_option('-o', '--output', action ='append',help='Export File.', metavar='OUTPUTFILE')
    p.add_option('-L', '--logfile', action ='store',help='Logfile configuration file.', metavar='LOGFILE')
    p.add_option('-x', '--execute', action ='store',help='Event application to launch.', metavar='EVENT')
    p.add_option('--verbose', action ='count',help='Change global log level, increasing log output.', metavar='LOGFILE')
    p.add_option('--quiet', action ='count',help='Change global log level, decreasing log output.', metavar='LOGFILE')
    p.add_option('--log-config', action ='store',help='Logfile configuration file, (overrides command line).', metavar='LOGFILE')
    p.add_option('--log-sql-info', action ='store_true',help='Echo all SQL commands.', metavar='LOGFILE')
    
    options, arguments = p.parse_args()
    autoEndorse = False
    anchor_needed = False
    format_needed = False
    actions = set([])
    subscriptions_selected = []
    subscription_url_list = []
    actionsrequiring_selections = set(['message','json','delete','info'])
    outputformats = set(['SMIME','message','lines'])
    output_format_selected = set([])
    inputformats = set(['uuid','url'])
    input_format_selected = set([])
    outputfiles = []
    databaseConnectionString = None
    eventCmd = None
    logFile = None
    certDir = None
    eventExecutionString = None
    debugSqlEcho = False
    if 'VMCATCHER_RDBMS' in os.environ:
        databaseConnectionString = os.environ['VMCATCHER_RDBMS']
    if 'VMCATCHER_LOG_CONF' in os.environ:
        logFile = os.environ['VMCATCHER_LOG_CONF']
    if 'VMCATCHER_DIR_CERT' in os.environ:
        certDir = os.environ['VMCATCHER_DIR_CERT']
    if 'VMCATCHER_SUB_EVENT' in os.environ:
        eventExecutionString = os.environ['VMCATCHER_SUB_EVENT']
    # Set up log file
    LoggingLevel = logging.WARNING
    LoggingLevelCounter = 2
    if options.verbose:
        LoggingLevelCounter = LoggingLevelCounter - options.verbose
        if options.verbose == 1:
            LoggingLevel = logging.INFO
        if options.verbose == 2:
            LoggingLevel = logging.DEBUG
    if options.quiet:
        LoggingLevelCounter = LoggingLevelCounter + options.quiet
    if LoggingLevelCounter <= 0:
        LoggingLevel = logging.DEBUG
    if LoggingLevelCounter == 1:
        LoggingLevel = logging.INFO
    if LoggingLevelCounter == 2:
        LoggingLevel = logging.WARNING
    if LoggingLevelCounter == 3:
        LoggingLevel = logging.ERROR
    if LoggingLevelCounter == 4:
        LoggingLevel = logging.FATAL
    if LoggingLevelCounter >= 5:
        LoggingLevel = logging.CRITICAL
    
    if options.log_config:
        logFile = options.log_config
    if logFile != None:
        if os.path.isfile(str(options.log_config)):
            logging.config.fileConfig(options.log_config)
        else:
            logging.basicConfig(level=LoggingLevel)
            log = logging.getLogger("main")
            log.error("Logfile configuration file '%s' was not found." % (options.log_config))
            sys.exit(1)
    else:
        
        logging.basicConfig(level=LoggingLevel)
    log = logging.getLogger("main")
    # Now logging is set up process other options    
    if options.log_sql_info:
        debugSqlEcho = True
    if options.cert_dir:
        certDir = options.cert_dir
    if options.list:
        actions.add('list')
        output_format_selected.add('lines')
    if options.update:
        actions.add('update')
        anchor_needed = True
        output_format_selected.add('lines')
    if options.subscribe:
        anchor_needed = True
        actions.add('subscribe')
        subscription_url_list = options.subscribe
    if options.uuid:
        subscriptions_selected = options.uuid
        input_format_selected.add('uuid')
    if options.uri:
        subscriptions_selected = options.uri
        input_format_selected.add('url')
    if options.format:
        if options.format in outputformats:
            output_format_selected.add(options.format)
            anchor_needed = True
        else:
            log.error("Invalid format '%s' allowed formats are '%s'" % (options.format,outputformats))
            sys.exit(1)
    if options.delete:
        actions.add('delete')
    if options.info:
        format_needed = True
        actions.add('info')
    if options.output:
        format_needed = True
        outputfiles = options.output
    if options.database:
        databaseConnectionString = options.database
    if options.auto_endorse:
        autoEndorse = True
    if options.execute:
        eventExecutionString = options.execute

    # 1 So we have some command line validation

    if databaseConnectionString == None:
        databaseConnectionString = 'sqlite:///vmcatcher.db'
        log.info("Defaulting DB connection to '%s'" % (databaseConnectionString))
    if len(actions) == 0:
        log.error("No actions selected")
        sys.exit(1)
    if len(actions) > 1:
        log.error("More than one action selected.")
        sys.exit(1)
    if format_needed and len(output_format_selected) == 0:
        log.error("No output format selected")
        sys.exit(1)

    # 1.1 Initate DB
    database = db_controler(databaseConnectionString,debugSqlEcho)
    # 1.2 Set up callbacks
    if eventExecutionString != None:
        EventInstance = EventObj(eventExecutionString)
        database.callbackEventImageNew = EventInstance.eventImageNew
    
    # 2 Initate CA's to manage files
    if anchor_needed:
        if certDir == None:
            certDir = "/etc/grid-security/certificates/"
            log.info("Defaulting Certificate directory to '%s'" % (certDir))
        database.setup_trust_anchor(certDir)

    # Handle conflicting actions
    actions_req_sel = actionsrequiring_selections.intersection(actions)

    actions_req_sel_len = len(actions_req_sel)
    if actions_req_sel_len == 1:
        if len(subscriptions_selected) == 0:
            log.error('No selections made.')
            sys.exit(1)
    if actions_req_sel_len > 1:
        log.error('Conflicting functions.')
        sys.exit(1)
    # Handle conflicting identifiers

    selectors_types = inputformats.intersection(input_format_selected)
    selectors_types_len = len(selectors_types)
    if selectors_types_len > 1:
        log.error('Conflicting selectors.')
        sys.exit(1)

    selector_str = 'uuid'

    if selectors_types_len == 1:
        selector_str = input_format_selected.pop()
    
    mapper = {'uuid' : queryby_uuid,
            'url' : queryby_uri,
        }
    database.setup_selector_factory(mapper[selector_str])

    # Handle the output_view

    outputformats_selections = outputformats.intersection(output_format_selected)
    outputformats_selections_len = len(outputformats_selections)
    if outputformats_selections_len > 1:
        log.error('Conflicting output formats.')
        sys.exit(1)
    selector_str = 'lines'
    if outputformats_selections_len == 1:
        selector_str = outputformats_selections.pop()
    mapper = {'lines' : output_driver_lines,
        'SMIME' : output_driver_smime,
        'message' : output_driver_message,
    }
    database.setup_view_factory(mapper[selector_str])
    
    
    # set default return code
    rc = 0
    
    if 'subscribe' in actions:
        if not database.subscriptions_subscribe(subscription_url_list,autoEndorse):
            log.error("Failed to subscribe to '%s'" % (subscription_url_list))
            sys.exit(1)
    if 'list' in actions:
        database.sessions_list()
    if 'update' in actions:
        rc = database.subscriptions_update()
    if 'delete' in actions:
        if not database.subscriptions_delete(subscriptions_selected):
            log.error("Failed to remove a subscription from '%s'" % (subscriptions_selected))
            rc = 1
    if 'dump' in actions:
        if not 'select' in actions:
            log.error('No subscriptions selected.')
        database.message_files(subscriptions_selected,outputfiles)
    if 'json' in actions:
        database.dumpfiles(subscriptions_selected,outputfiles)
    if 'info' in actions:
        database.subscriptions_info(subscriptions_selected,outputfiles)
    sys.exit(rc)
if __name__ == "__main__":
    main()
