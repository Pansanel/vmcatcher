#!/usr/bin/env python
import sys
if sys.version_info < (2, 4):
    print "Your python interpreter is too old. Please consider upgrading."
    sys.exit(1)

if sys.version_info < (2, 5):
    import site
    import os.path
    from distutils.sysconfig import get_python_lib
    found = False
    module_dir = get_python_lib()
    for name in os.listdir(module_dir):
        lowername = name.lower()
        if lowername[0:10] == 'sqlalchemy' and 'egg' in lowername:
            sqlalchemy_dir = os.path.join(module_dir, name)
            if os.path.isdir(sqlalchemy_dir):
                site.addsitedir(sqlalchemy_dir)
                found = True
                break
    if not found:
        print "Could not find SQLAlchemy installed."
        sys.exit(1)

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import IntegrityError, DatabaseError, ProgrammingError
import hepixvmlis.databaseDefinition as model
import os
import logging
import optparse
import smimeX509validation.loadcanamespace as loadcanamespace
from hepixvmlis.__version__ import version
import hepixvmlis
import urllib2
import urllib
import hashlib
import datetime
from hepixvmitrust.vmitrustlib import VMimageListDecoder as VMimageListDecoder
from hepixvmitrust.vmitrustlib import time_format_definition as time_format_definition
try:
    import simplejson as json
except:
    import json

# command line error codes.
#  10 failed to download image list.
#  11 failed to validate image list.
#  12 metadata and certificate dont match.
#  13 Endorser not authorised on subscription.
#  14 trust anchor missing
#  15 Database integrity error.

#  31 imagelist dc:identifier invalid.
#  32 image dc:identifier invalid.
#  33 imagelist dc:date:created invalid.
#  34 image has missing parameters in the message.
#  35 image has missing parameters in the message.
#  36 image is not registeresd with subscription.
#  37 Message was not valid JSON.
#  38 Message JSON was not valid to build image list.



class EventObj(object):
    def __init__(self,eventExecutionString):
        self.eventExecutionString = eventExecutionString
        self.env = os.environ
        self.log = logging.getLogger("Events")
    def launch(self,env):
        process = subprocess.Popen([self.eventExecutionString], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,env=env)
        processRc = None
        handleprocess = True
        counter = 0
        stdout = ''
        stderr = ''
        timeout = 10
        while handleprocess:
            counter += 1
            cout,cerr = process.communicate()
            stdout += cout
            stderr += cerr
            process.poll()
            processRc = process.returncode
            if processRc != None:
                break
            if counter == timeout:
                os.kill(process.pid, signal.SIGQUIT)
            if counter > timeout:
                os.kill(process.pid, signal.SIGKILL)
                processRc = -9
                break
            time.sleep(1)
        return (processRc,stdout,stderr)

    def eventProcess(self,EventStr,metadata):
        # Note keys 'sha512', 'uuid','size' are depricated.
        mappingdict = {'sha512' : 'VMILS_EVENT_SL_CHECKSUM_SHA512',
            'uuid' : 'VMILS_EVENT_DC_IDENTIFIER',
            'size' : 'VMILS_EVENT_HV_SIZE',
            'sha512' : 'VMILS_EVENT_SL_CHECKSUM_SHA512',
            # End of depricated options
            'filename' : 'VMILS_EVENT_FILENAME',
            'dc:identifier' : 'VMILS_EVENT_DC_IDENTIFIER',
            'hv:uri' : 'VMILS_EVENT_HV_URI',
            'hv:size' : 'VMILS_EVENT_HV_SIZE',
            'dc:description' : 'VMILS_EVENT_DC_DESCRIPTION',
            'dc:title' : 'VMILS_EVENT_DC_TITLE',
            'hv:hypervisor' : 'VMILS_EVENT_HV_HYPERVISOR',
            'hv:version' : 'VMILS_EVENT_HV_VERSION',
            'sl:arch' : 'VMILS_EVENT_SL_ARCH',
            'sl:comments' : 'VMILS_EVENT_SL_COMMENTS',
            'sl:os' : 'VMILS_EVENT_SL_OS',
            'sl:osversion' : 'VMILS_EVENT_SL_OSVERSION',
            'sl:checksum:sha512' : 'VMILS_EVENT_SL_CHECKSUM_SHA512'}
        newEnv = self.env
        newEnv['VMILS_EVENT_TYPE'] = EventStr
        for key in mappingdict.keys():
            if key in metadata.keys():
                newEnv[str(mappingdict[key])] = str(metadata[key])
        rc,stdout,stderr = self.launch(newEnv)
        if rc != 0:
            self.log.error("Event command '%s' exit code '%s' failed for VMILS_EVENT_TYPE='%s'." % (self.eventExecutionString,rc,newEnv['VMILS_EVENT_TYPE']))
            self.log.info("stdout=%s" % (stdout))
            self.log.info("stderr=%s" % (stderr))
            return
        self.log.debug("stdout=%s" % (stdout))
        return
    def eventImageNew(self,metadata):
        self.eventProcess("ImageNew",metadata)


class db_actions:
    def __init__(self,session):
        self.session = session
        self.log = logging.getLogger("db_actions")
    def endorser_get(self,metadata):
        return self.session.query(model.Endorser).\
                filter(model.Endorser.id==model.EndorserPrincible.id).\
                filter(model.EndorserPrincible.hv_dn==metadata[u'hv:dn']).\
                filter(model.EndorserPrincible.hv_ca==metadata[u'hv:ca'])
    def endorser_create(self,metadata):
        gotquery = self.endorser_get(metadata)
        if gotquery.count() != 0:
            return gotquery
        newlist = model.Endorser(metadata)
        self.session.add(newlist)
        self.session.commit()
        new_endorser = model.EndorserPrincible(newlist.id,metadata)

        self.session.add(new_endorser)
        self.session.commit()
        return self.endorser_get(metadata)
    def subscription_get(self,metadata):
        subscriptionlist = self.session.query(model.Subscription).\
                filter(model.Subscription.uri==metadata[u'hv:uri'])
        return subscriptionlist

    def subscription_create(self,metadata,authorised):
        subscription_query = self.subscription_get(metadata)
        if subscription_query.count() > 0:
            return subscription_query
        endorser_list = self.endorser_get(metadata)
        if endorser_list.count() == 0:
            return subscription_query
        endorser = endorser_list.one()
        endorserId = int(endorser.id)
        new_subscription = model.Subscription(metadata)
        # We will make the new subscription enabled by default
        new_subscription.authorised = True
        self.session.add(new_subscription)
        self.session.commit()
        new_auth = model.SubscriptionAuth(new_subscription.id,endorser.id,authorised)
        self.session.add(new_auth)
        try:
            self.session.commit()
        except IntegrityError,E:
             self.log.error("Database integrity error '%s' while subscribing to  '%s'." % (E.args,metadata))
             self.log.debug(E.params)
             self.session.rollback()
        return self.subscription_get(metadata)

    def ImageDefinition_get(self,subscriptionKey,metadata):
        subscriptionlist = self.session.query(model.ImageDefinition).\
                filter(model.ImageDefinition.subscription==subscriptionKey).\
                filter(model.ImageDefinition.identifier == metadata[u'dc:identifier'])
        return subscriptionlist

    def ImageDefinition_create(self,subscriptionKey,metadata):
        ImageDefinitionQuery = self.ImageDefinition_get(subscriptionKey,metadata)
        if ImageDefinitionQuery.count() > 0:
            return ImageDefinitionQuery
        newlist = model.ImageDefinition(subscriptionKey,metadata)
        self.session.add(newlist)
        self.session.commit()
        ImageDefinitionQuery = self.ImageDefinition_get(subscriptionKey,metadata)
        return ImageDefinitionQuery


class queryby_base:
    """"Base class for querying subscriptions"""
    def __init__(self,session):
        self.session = session
    def subscription_by_id(self,private_id):
        subscriptionlist = self.session.query(model.Subscription).\
                filter(model.Subscription.id==private_id)
        return subscriptionlist
    def subscription_by_uri(self,uri):
        subscriptionlist = self.session.query(model.Subscription).\
                filter(model.Subscription.uri==uri)
        return subscriptionlist
    def subscription_by_uuid(self,uuid):
        subscriptionlist = self.session.query(model.Subscription).\
                filter(model.Subscription.identifier==uuid)
        return subscriptionlist
    def imagelist_by_id(self,private_id):
        subscriptionlist = self.session.query(model.ImageListInstance).\
                filter(model.ImageListInstance.id==private_id)
        return subscriptionlist

        # Now the virtual class
    def subscription_get(self,by_id):
        return self.subscription_by_id(private_id)


class queryby_uri(queryby_base):
    def subscription_get(self,url):
        return self.subscription_by_uri(url)

class queryby_uuid(queryby_base):
    def subscription_get(self,uuid):
        return self.subscription_by_uuid(uuid)


class output_driver_base:
    def __init__(self,file_pointer,session,anchor):
        self.session = session
        self.log = logging.getLogger("db_actions")
        self.file_pointer = file_pointer
        self.anchor = anchor
    def display_subscription_imagelist(self,subscription,imagelist):
        status = None

        self.display_subscription(subscription)
        self.display_imagelist(imagelist)

        return True
    def display_subscription(self,subscription):
        pass
    def display_imagelist(self,imagelist):
        pass
    def subscriptions_lister(self):
        pass

class output_driver_smime(output_driver_base):
    def display_subscription(self,subscription):
        pass
    def display_imagelist(self,imagelist):
        self.file_pointer.write (imagelist.data)

class output_driver_message(output_driver_base):
    def __init__(self,file_pointer,session,anchor):
        output_driver_base.__init__(self,file_pointer,session,anchor)
        self.log = logging.getLogger("output_driver_message")
    def display_subscription(self,subscription):
        pass
    def display_imagelist(self,imagelist):
        try:
            validated_data = self.anchor.validate_text(str(imagelist.data))
        except loadcanamespace.SmimeX509ValidationError,E:
            self.log.error("Failed to validate text for '%s' produced error '%s'" % (imagelist,E))
            return False
        self.file_pointer.write (validated_data['data'])
        return True

class output_driver_lines(output_driver_base):
    def display_subscription(self,subscription):
        self.file_pointer.write ('subscription.dc:identifier=%s\n' % (subscription.identifier))
        self.file_pointer.write ('subscription.dc:description=%s\n' % (subscription.description))
        self.file_pointer.write ('subscription.sl:authorised=%s\n' % (subscription.authorised))
        self.file_pointer.write ('subscription.hv:uri=%s\n' % (subscription.uri))
        if subscription.updated:
            self.file_pointer.write ('subscription.dc:date:updated=%s\n' % (subscription.updated.strftime(time_format_definition)))
        else:
            self.file_pointer.write ('subscription.dc:date:updated=%s\n'% (False))
        return True

    def display_imagelist(self,imagelist):
        self.file_pointer.write ('imagelist.dc:date:imported=%s\n' % (imagelist.imported.strftime(time_format_definition)))
        self.file_pointer.write ('imagelist.dc:date:created=%s\n' % (imagelist.created.strftime(time_format_definition)))
        self.file_pointer.write ('imagelist.dc:date:expires=%s\n' % (imagelist.expires.strftime(time_format_definition)))
        if imagelist.expired == None:
            self.file_pointer.write ('imagelist.expired=0\n')
        else:
            self.file_pointer.write ('imagelist.expired=%s\n' % (imagelist.expired.strftime(time_format_definition)))
    def subscriptions_lister(self):
        subauthq = self.session.query(model.Subscription).all()
        for item in subauthq:
            self.file_pointer.write ("%s\t%s\t%s\n" % (item.identifier,item.authorised,item.uri))

class db_controler:
    def __init__(self,dboptions):
        self.log = logging.getLogger("db_controler")
        self.engine = create_engine(dboptions, echo=False)
        model.init(self.engine)
        self.SessionFactory = sessionmaker(bind=self.engine)
        self.anchor = None
        self.factory_selector = None
        self.factory_view = None
        # Set all callbacks to empty
        self.callbackEventImageNew = None

    def setup_trust_anchor(self,directory):
        self.anchor = loadcanamespace.TrustAnchor()
        self.anchor.update_ca_list(directory)
    def setup_selector_factory(self,factory):
        self.factory_selector = factory
    def setup_view_factory(self,factory):
        self.factory_view = factory

    # Utility functions
    def check_factories(self):
        if self.factory_view == None:
            self.log.warning("factory_view not available.")
            return False
        if self.factory_selector == None:
            self.log.warning("selector not available.")
            return False
        return True
    def unsigned_message_by_identifier_tofilepath(self,instructions):


        Session = self.SessionFactory()
        db = db_actions(Session)
        for instruction in instructions:
            print instruction

        for selection_uuid in subscriptions_selected:
            db.sdsdsd(selection_uuid)
        Session.commit()
    def sessions_list(self):
        Session = self.SessionFactory()
        selector = self.factory_selector(Session)
        view = self.factory_view(sys.stdout,Session,self.anchor)
        view.subscriptions_lister()
        return True
    
    def subscriptions_delete(self,subscriptions_selected):
        foundOne = False
        Session = self.SessionFactory()
        db = db_actions(Session)
        selector = self.factory_selector(Session)
        query_subscription = selector.subscription_get(subscriptions_selected)
        for selection_item in subscriptions_selected:
            query_subscription = selector.subscription_get(selection_item)
            for a_sub in query_subscription:
                Session.delete(a_sub)
                foundOne = True
        Session.commit()
        return foundOne
    def subscriptions_subscribe(self,urls_selected,autoEndorse):
        rc = True
        Session = self.SessionFactory()
        db = db_actions(Session)
        for uri in urls_selected:
            if not self.subscribe_file(Session,self.anchor,uri,autoEndorse):
                rc = False
        return rc


    def subscriptions_info(self,subscriptions_selected,outputfiles):
        if not self.check_factories():
            return False
        pairs, extra_selectors ,extra_paths = pairsNnot(subscriptions_selected,outputfiles)

        for item in extra_selectors:
            pairs.append([item,None])

        errorhappened = False
        Session = self.SessionFactory()
        selector = self.factory_selector(Session)
        for pair in pairs:
            selector_filter = pair[0]
            output_file_name = pair[1]
            output_fileptr = sys.stdout
            if output_file_name != None:
                output_fileptr = open(output_file_name,'w+')
                output_fileptr.flush()
            query_subscription = selector.subscription_get(selector_filter)
            if query_subscription.count() == 0:
                self.log.warning("Selections '%s' does not match any known subscriptions." % (selector_filter))
                continue
            view = self.factory_view(output_fileptr,Session,self.anchor)

            for item in query_subscription:
                view.display_subscription(item)
                query_imagelist = selector.imagelist_by_id(item.imagelist_latest)
                for imagelist in query_imagelist:
                    view.display_imagelist(imagelist)

            if output_file_name != None:
                output_fileptr.close()
    def setEventObj(self,obj):
        self.eventObj = obj

    def subscribe_file(self,Session,anchor,filename,autoEndorse):
        req = urllib2.Request(url=filename)
        f = urllib2.urlopen(req)
        try:
            validated_data = anchor.validate_text(f.read())
        except loadcanamespace.SmimeX509ValidationError,E:
            self.log.error("Validate text '%s' produced error '%s'" % (filename,E))
            return False
        jsontext = json.loads(validated_data['data'])
        if jsontext == None:
            self.log.error("Message downlaoded from '%s' was not valid JSON." % (filename))
            return False
        vmilist = VMimageListDecoder(jsontext)
        if vmilist == None:
            self.log.error("Failed to decode the json as an image list Object for '%s'." % (filename))
            return False
        metadata = {}
        metadata.update(vmilist.metadata)
        metadata.update(vmilist.endorser.metadata)
        if u'dc:identifier' not in metadata.keys():
            self.log.error('list dc:identifier does not found')
            return False
        if metadata[u'hv:dn'] != validated_data['signer_dn']:
            self.log.error('Endorser DN does not match signature')
            return False
        if metadata[u'hv:ca'] != validated_data['issuer_dn']:
            self.log.error('list hv:ca does not match signature')
            return False
        if metadata[u'hv:uri'] != filename:
            self.log.warning('list hv:uri does not match subscription uri')
        db = db_actions(Session)
        endorser_list = db.endorser_get(metadata)
        if endorser_list.count() == 0:
            if not autoEndorse:
                self.log.error("Endorser '%s':'%s' was not found in database." % (metadata[u'hv:dn'],metadata[u'hv:ca']))
                self.log.info("Use '--auto-endorse' to add endorser '%s':'%s' to subscription database." % (metadata[u'hv:dn'],metadata[u'hv:ca']))
                return False
            else:
                # We can create an endorser.
                endorser_list = db.endorser_create(metadata)
                self.log.warning("Endorser '%s':'%s' added to database." % (metadata[u'hv:dn'],metadata[u'hv:ca']))
                
                if endorser_list.count() == 0:
                    self.log.error('Failed to create an authorised endorser in Database.')
                    return False
        subscription_query = db.subscription_create(metadata,True)
        if subscription_query.count() != 1:
            self.log.error('Creation of Subscription referance failed.')
            return False
        subscription = subscription_query.one()
        subscriptionKey = int(subscription.id)
        failedToCreateImages = []
        for imageReferance in vmilist.images:
            # Now we creat image definitions
            metadata = {}
            metadata.update(imageReferance.metadata)
            metadata['cache'] = 0
            ImageDefinition_query = db.ImageDefinition_create(subscriptionKey,metadata)
            if ImageDefinition_query.count() != 1:
                self.log.error('Creation of ImageDefinition referance failed.')
                failedToCreateImages.append(imageReferance)
                continue
        if len(failedToCreateImages) > 0:
            return False
        return True
    
    
    def subscript_update_image(self,Session,subscription,imagelistref,imageObj):
        subscriptionKey = subscription.id
        ProcessingSubscriptionUuid = subscription.identifier
        if not u'dc:identifier' in imageObj.metadata.keys():
            self.log.error('Image had no ID so ignored')
            # Error code - imagelist dc:identifier invalid.
            return 31
        db = db_actions(Session)
        imageDefQuery = db.ImageDefinition_get(subscriptionKey,imageObj.metadata)
        if imageDefQuery.count() != 1:
            if self.callbackEventImageNew != None:
                self.callbackEventImageNew(imageObj.metadata)
            # Triggor an event for new image.
            self.log.error("ImageId '%s' not accepted for subscription '%s'" %
                (imageObj.metadata[u'dc:identifier'],ProcessingSubscriptionUuid))
            # Error code - image dc:identifier invalid.
            return 32
        ThisImageDef = imageDefQuery.one()

        ThisImageDefId = int(ThisImageDef.id)
        #print ("ThisImageDefId=%s" % (ThisImageDefId))
        try:
            imageinstance = model.ImageInstance(imagelistref,ThisImageDefId,imageObj.metadata)
        except KeyError, E:
            self.log.error("missing parameters '%s'" % E.message)
            Session.rollback()
            return 34
        Session.add(imageinstance)
        try:
            Session.commit()
        except IntegrityError,E:
            self.log.error("Database integrity error '%s' processing '%s'." % (E.args,ProcessingSubscriptionUuid))
            self.log.debug(E.params)
            Session.rollback()
            return 0
        # So now we have done the updating of the database and just need to update 
        # the latest image instance record in the database.
        
        latestimageInstanceQuery = Session.query(model.ImageInstance).\
            filter(model.ImageInstance.fkimagelistinstance == imagelistref).\
            filter(model.ImageInstance.fkIdentifier == ThisImageDefId)
        if latestimageInstanceQuery.count() != 1:
            print 'ddddddddddddddddddddddddddddddd'
            return 0
        imageInstancelatest = latestimageInstanceQuery.one()
        imageDefQuery = db.ImageDefinition_get(subscriptionKey,imageObj.metadata)
        if imageDefQuery.count() != 1:
            self.log.error("ImageId '%s' not accepted for subscription '%s'" %
                (imageObj.metadata[u'dc:identifier'],ProcessingSubscriptionUuid))
            return 36
        ThisImageDef = imageDefQuery.one()
        ThisImageDef.latest = imageInstancelatest.id
        Session.add(ThisImageDef)
        Session.commit()
        return 0

    def subscription_update(self,Session,subscription):
        subscriptionKey = int(subscription.id)
        ProcessingSubscriptionUuid = str(subscription.identifier)
        self.log.info("Updating:%s" % (ProcessingSubscriptionUuid))
        req = urllib2.Request(url=subscription.uri)
        try:
            f = urllib2.urlopen(req)
        except urllib2.URLError,E:
            # Python 2.6 Exception
            self.log.error("Download of url '%s' failed." % (subscription.uri))
            # Error code - failed to download image list.
            return 10
        except OSError:
            # Python 2.4 Exception
    	    self.log.error("Download of url '%s' failed." % (subscription.uri))
            # Error code - failed to download image list.
            return 10
        update_unprocessed = f.read()
        # Now we have the update lets first check its hash
        messagehash = hashlib.sha512(update_unprocessed).hexdigest()
        messagehash_q = Session.query(model.ImageListInstance).\
            filter(model.ImageListInstance.data_hash==messagehash)
        count = messagehash_q.count()
        now = datetime.datetime.utcnow()
        if count != 0:
            self.log.debug('Hash already found')
            for message in messagehash_q:
                if now > message.expires:
                    self.log.warning("Image list '%s' has expired on: '%s'" % (ProcessingSubscriptionUuid,message.expires))
                    message.expired = now
                    Session.commit()
            return 0
        #Now we check its authenticity
        try:
            validated_data = self.anchor.validate_text(update_unprocessed)
        except loadcanamespace.SmimeX509ValidationError,E:
            self.log.error("Failed to process validate text for '%s' produced error '%s'" % (subscriptionKey,E))
            # Error code - failed to validate image list.
            return 11
        data = validated_data['data']
        dn = validated_data['signer_dn']
        ca = validated_data['issuer_dn']
        jsontext = json.loads(data)
        if jsontext == None:
            self.log.error("Downlaoded metadata from '%s' was not valid JSON." % (subscriptionKey))
            return 37
        vmilist = VMimageListDecoder(jsontext)
        if vmilist == None:
            self.log.error("Downlaoded metadata from '%s' was not valid image list Object." % (subscriptionKey))
            return 38

        metadata = vmilist.metadata
        metadata[u'data'] = update_unprocessed
        metadata[u'data-hash'] = messagehash

        if vmilist.endorser.metadata[u'hv:dn'] != dn:
            self.log.error("Endorser DN does not match signature for '%s'" (ProcessingSubscriptionUuid))
            self.log.info("Expected DN '%s'" % (vmilist.endorser.metadata[u'hv:dn']))
            self.log.info("Downloaded DN '%s'" % (dn))
            # Error code - metadata and certificate dont match.
            return 12
        if vmilist.endorser.metadata[u'hv:ca'] != ca:
            self.log.error("list hv:ca does not match signature for '%s'" % (ProcessingSubscriptionUuid))
            self.log.info("Expected CA '%s'" % (vmilist.endorser.metadata[u'hv:ca']))
            self.log.info("Downloaded CA '%s'" % (dn))
            # Error code - metadata and certificate dont match.
            return 12
        if vmilist.metadata[u'hv:uri'] != subscription.uri:
            self.log.error("list hv:uri does not match subscription uri for '%s'" % (ProcessingSubscriptionUuid))
            self.log.info("Expected URI '%s'" % (subscription.uri))
            self.log.info("Downloaded URI '%s'" % (vmilist.metadata[u'hv:uri']))
            # Error code - metadata and certificate dont match.
            return 12
        if vmilist.metadata[u'dc:identifier'] != subscription.identifier:
            self.log.error("list dc:identifier does not match subscription uuid for '%s'" % ProcessingSubscriptionUuid)
            self.log.info("Expected identifier '%s'" % (subscription.identifier))
            self.log.info("Downloaded identifier '%s'" % (vmilist.metadata[u'dc:identifier']))
            # Error code - imagelist dc:identifier invalid.
            return 31
        now = datetime.datetime.utcnow()
        if now < vmilist.metadata[u'dc:date:created']:
            self.log.error("Image list '%s' has an invalid creation date as in the future." % (ProcessingSubscriptionUuid))
            return 33
        if now > vmilist.metadata[u'dc:date:expires']:
            self.log.warning("Downloaded image list '%s' has expired." % (ProcessingSubscriptionUuid))
            removeauthorsiation = True
            metadata[u'expired'] = now

        # Now we know the data better check the SubscriptionAuth
        subauthq = Session.query(model.SubscriptionAuth).\
            filter(model.Endorser.id==model.EndorserPrincible.id).\
            filter(model.EndorserPrincible.hv_dn==dn).\
            filter(model.EndorserPrincible.hv_ca==ca).\
            filter(model.SubscriptionAuth.endorser == model.Endorser.id).\
            filter(model.SubscriptionAuth.subscription == model.Subscription.id).\
            filter(model.Subscription.id == subscription.id)

        count = subauthq.count()
        if count == 0:
            self.log.error('Endorser not authorised on subscription %s' % (ProcessingSubscriptionUuid))
            # Error code - Endorser not authorised on subscription.
            return 13
        authsub = subauthq.one()
        imagelist = model.ImageListInstance(authsub.id,metadata)
        Session.add(imagelist)
        try:
            Session.commit()
        except IntegrityError,E:
            self.log.error("Database integrity error '%s' processing '%s'." % (E.args,ProcessingSubscriptionUuid))
            self.log.debug(E.params)
            Session.rollback()
            # Error code - Database integrity error.
            return 15
        imagelistref = int(imagelist.id)
        # Now make a global return number
        globalRc = 0
        for imageObj in vmilist.images:
            # Now update each Image
            thisRc = self.subscript_update_image(Session,subscription,imagelistref,imageObj)
            if thisRc != 0:
                globalRc = thisRc

        if subscription.imagelist_latest != None:
            oldimagelist_q = Session.query(model.ImageListInstance).\
                filter(model.ImageListInstance.id == subscription.imagelist_latest)
            for imagelist in oldimagelist_q:
                imagelist.authorised = False
                Session.add(imagelist)
        subscription.updated = datetime.datetime.utcnow()

        subscription.imagelist_latest = imagelistref
        Session.add(subscription)
        Session.commit()
        return globalRc
        
    def subscriptions_update(self):
        if self.anchor == None:
            self.log.warning("No enabled certificates, check your x509 dir.")
            return 12
        Session = self.SessionFactory()
        db = db_actions(Session)
        rc = 0
        subscriptionlist = Session.query(model.Subscription).all()
        for subscription in subscriptionlist:
            thisRc = self.subscription_update(Session,subscription)
            if thisRc != 0:
                rc = thisRc
        return rc
         

# User interface

def pairsNnot(list_a,list_b):
    len_generate_list = len(list_a)
    len_image_list = len(list_b)
    ocupies_generate_list = set(range(len_generate_list))
    ocupies_image_list = set(range(len_image_list))
    ocupies_pairs = ocupies_image_list.intersection(ocupies_generate_list)
    diff_a = ocupies_generate_list.difference(ocupies_image_list)
    diff_b = ocupies_image_list.difference(ocupies_generate_list)
    arepairs = []
    for i in ocupies_pairs:
        arepairs.append([list_a[i],list_b[i]])
    notpairs_a = []
    for i in diff_a:
        notpairs_a.append(list_a[i])
    notpairs_b = []
    for i in diff_b:
        notpairs_b.append(list_b[i])

    return arepairs,notpairs_a,notpairs_b



def main():
    log = logging.getLogger("main")
    """Runs program and handles command line options"""
    p = optparse.OptionParser(version = "%prog " + version)
    p.add_option('-l', '--list', action ='store_true',help='list subscriptions')
    p.add_option('-d', '--database', action ='store', help='Database Initiation string')
    p.add_option('-s', '--subscribe', action ='append',help='Subscribe to imagelist available at URI', metavar='INPUTURL')
    p.add_option('-e', '--auto-endorse', action ='store_true',help='Add endorser in your subscribe to imagelist action.')
    p.add_option('-c', '--cert-dir', action ='store',help='Certificate directory.', metavar='INPUTDIR')
    p.add_option('-U', '--update', action ='store_true',help='update image metadata')
    p.add_option('-u', '--uuid', action ='append',help='Select subscription', metavar='UUID')
    p.add_option('-r', '--uri', action ='append',help='Select subscription', metavar='URL')
    p.add_option('-f', '--format', action ='store',help='Sets the output format')
    p.add_option('-D', '--delete', action ='store_true',help='Delete subscription')
    p.add_option('-i', '--info', action ='store_true',help='Information on subscription')
    p.add_option('-o', '--output', action ='append',help='Export File.', metavar='OUTPUTFILE')
    p.add_option('-L', '--logfile', action ='store',help='Logfile configuration file.', metavar='LOGFILE')
    p.add_option('-x', '--execute', action ='store',help='Event application to launch.', metavar='EVENT')
    options, arguments = p.parse_args()
    autoEndorse = False
    anchor_needed = False
    format_needed = False
    actions = set([])
    subscriptions_selected = []
    subscription_url_list = []
    actionsrequiring_selections = set(['message','json','delete','info'])
    outputformats = set(['SMIME','message','lines'])
    output_format_selected = set([])
    inputformats = set(['uuid','url'])
    input_format_selected = set([])
    outputfiles = []
    databaseConnectionString = None
    eventCmd = None
    logFile = None
    certDir = None
    eventExecutionString = None
    if 'VMILS_RDBMS' in os.environ:
        databaseConnectionString = os.environ['VMILS_RDBMS']
    if 'VMILS_LOG_CONF' in os.environ:
        logFile = os.environ['VMILS_LOG_CONF']
    if 'VMILS_DIR_CERT' in os.environ:
        certDir = os.environ['VMILS_DIR_CERT']
    if 'VMILS_SUB_EVENT' in os.environ:
        eventExecutionString = os.environ['VMILS_SUB_EVENT']
    
    # Set up log file
    if options.logfile:
        logFile = options.logfile
    if logFile != None:
        if os.path.isfile(str(options.logfile)):
            logging.config.fileConfig(options.logfile)
        else:
            logging.basicConfig(level=logging.INFO)
            log = logging.getLogger("main")
            log.error("Logfile configuration file '%s' was not found." % (options.logfile))
            sys.exit(1)
    else:
        logging.basicConfig(level=logging.INFO)
    log = logging.getLogger("main")
    # Now logging is set up process other options
    if options.cert_dir:
        certDir = options.cert_dir
    if options.list:
        actions.add('list')
        output_format_selected.add('lines')
    if options.update:
        actions.add('update')
        anchor_needed = True
        output_format_selected.add('lines')
    if options.subscribe:
        anchor_needed = True
        actions.add('subscribe')
        subscription_url_list = options.subscribe
    if options.uuid:
        subscriptions_selected = options.uuid
        input_format_selected.add('uuid')
    if options.uri:
        subscriptions_selected = options.uri
        input_format_selected.add('url')
    if options.format:
        if options.format in outputformats:
            output_format_selected.add(options.format)
            anchor_needed = True
        else:
            log.error("Invalid format '%s' allowed formats are '%s'" % (options.format,outputformats))
            sys.exit(1)
    if options.delete:
        actions.add('delete')
    if options.info:
        format_needed = True
        actions.add('info')
    if options.output:
        format_needed = True
        outputfiles = options.output
    if options.database:
        databaseConnectionString = options.database
    if options.auto_endorse:
        autoEndorse = True
    if options.execute:
        eventExecutionString = options.execute

    # 1 So we have some command line validation

    if databaseConnectionString == None:
        databaseConnectionString = 'sqlite:///vmilsubscriber.db'
        log.info("Defaulting DB connection to '%s'" % (databaseConnectionString))
    if len(actions) == 0:
        log.error("No actions selected")
        sys.exit(1)
    if len(actions) > 1:
        log.error("More than one action selected.")
        sys.exit(1)
    if format_needed and len(output_format_selected) == 0:
        log.error("No output format selected")
        sys.exit(1)

    # 1.1 Initate DB
    database = db_controler(databaseConnectionString)
    # 1.2 Set up callbacks
    if eventExecutionString != None:
        EventInstance = EventObj(eventExecutionString)
        database.callbackEventImageNew = EventInstance.eventImageNew
    
    # 2 Initate CA's to manage files
    if anchor_needed:
        if certDir == None:
            certDir = "/etc/grid-security/certificates/"
            log.info("Defaulting Certificate directory to '%s'" % (certDir))
        database.setup_trust_anchor(certDir)

    # Handle conflicting actions
    actions_req_sel = actionsrequiring_selections.intersection(actions)

    actions_req_sel_len = len(actions_req_sel)
    if actions_req_sel_len == 1:
        if len(subscriptions_selected) == 0:
            log.error('No selections made.')
            sys.exit(1)
    if actions_req_sel_len > 1:
        log.error('Conflicting functions.')
        sys.exit(1)
    # Handle conflicting identifiers

    selectors_types = inputformats.intersection(input_format_selected)
    selectors_types_len = len(selectors_types)
    if selectors_types_len > 1:
        log.error('Conflicting selectors.')
        sys.exit(1)

    selector_str = 'uuid'

    if selectors_types_len == 1:
        selector_str = input_format_selected.pop()
    
    mapper = {'uuid' : queryby_uuid,
            'url' : queryby_uri,
        }
    database.setup_selector_factory(mapper[selector_str])

    # Handle the output_view

    outputformats_selections = outputformats.intersection(output_format_selected)
    outputformats_selections_len = len(outputformats_selections)
    if outputformats_selections_len > 1:
        log.error('Conflicting output formats.')
        sys.exit(1)
    selector_str = 'lines'
    if outputformats_selections_len == 1:
        selector_str = outputformats_selections.pop()
    mapper = {'lines' : output_driver_lines,
        'SMIME' : output_driver_smime,
        'message' : output_driver_message,
    }
    database.setup_view_factory(mapper[selector_str])
    
    
    # set default return code
    rc = 0
    
    if 'subscribe' in actions:
        if not database.subscriptions_subscribe(subscription_url_list,autoEndorse):
            log.error("Failed to subscribe to '%s'" % (subscription_url_list))
            sys.exit(1)
    if 'list' in actions:
        database.sessions_list()
    if 'update' in actions:
        rc = database.subscriptions_update()
    if 'delete' in actions:
        if not database.subscriptions_delete(subscriptions_selected):
            log.error("Failed to remove a subscription from '%s'" % (subscriptions_selected))
            rc = 1
    if 'dump' in actions:
        if not 'select' in actions:
            log.error('No subscriptions selected.')
        database.message_files(subscriptions_selected,outputfiles)
    if 'json' in actions:
        database.dumpfiles(subscriptions_selected,outputfiles)
    if 'info' in actions:
        database.subscriptions_info(subscriptions_selected,outputfiles)
    sys.exit(rc)
if __name__ == "__main__":
    main()
